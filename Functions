import numpy as np
import math as m
from astropy.coordinates import SkyCoord
from astropy import units as u
import pandas as pd
from matplotlib.patches import Polygon
import matplotlib.pyplot as plt
import cv2
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.edge.service import Service
from webdriver_manager.microsoft import EdgeChromiumDriverManager

import time
import pyautogui
from PIL import ImageGrab


#Isochrone probability ==========================================
#Functions to define how likely stars are member candidates
def PCMD(xdata,ydata,isox1,isoy1, isox2, isoy2):
    P_CMD = []
    eta_CMD = 0.3
    for i in range(len(xdata)):
        py = []
        xd1 = (xdata[i] - isox1)**2 
        yd1 = (ydata[i] - isoy1)**2
        py1 = np.sqrt(xd1 + yd1)     #pythagon for first isochrone label
        py.append(np.min(py1))
        xd2 = (xdata[i] - isox2)**2 
        yd2 = (ydata[i] - isoy2)**2
        py2 = np.sqrt(xd2 + yd2)     #pythag for 2nd
        py.append(np.min(py2))
        mini = np.min(py)           #figurinh which one is the smallest                 
        P_cmd = np.exp(-(mini**2)/(2*(eta_CMD**2))) #using the smallest distance to caluclate probability (Charles 2023)
        P_CMD.append(P_cmd)
    return P_CMD

def PCMD_av(xdata,ydata,isox1,isoy1, isox2, isoy2):
    P_CMD_av = []
    eta_CMD = 0.3
    for i in range(len(xdata)):
        py = []
        xd1 = (xdata[i] - isox1)**2 
        yd1 = (ydata[i] - isoy1)**2
        py1 = np.sqrt(xd1 + yd1)
        py.append(np.min(py1))
        xd2 = (xdata[i] - isox2)**2 
        yd2 = (ydata[i] - isoy2)**2
        py2 = np.sqrt(xd2 + yd2)
        py.append(np.min(py2))
        mini = np.min(py)
        P_cmd_av = np.exp(-(mini**2)/(2*(eta_CMD**2)))
        P_CMD_av.append(P_cmd_av)
    return np.sum(P_CMD_av)

#Set up =============================================================
def setup(xbin, ybin, x, y, size):
    Xob = xbin[x]+size/2    #the centre of the pixel.
    Yob = ybin[y]+size/2
    c_Ob = []
    for i in range(len(Xob)):
        C_Ob = SkyCoord(Xob[i], Yob[i], frame='icrs', unit=(u.deg,u.deg))
        c_Ob.append(C_Ob)
    return c_Ob

#===================================================================
#Box around isochrone (CM Cuts) ====================================
def front_to_back(first, second):
    """Join two arrays front to back."""
    return np.append(first, second[::-1])

def box(prob, gmag, rmag, NewIsor, NewIsog, NewIsoR, NewIsoG):
    #creating data frames for the isochrones
    iso4_df = pd.DataFrame() 
    iso3_df = pd.DataFrame()
    isom_df = pd.DataFrame()    
    iso4_df['mag_r'] = NewIsor[prob]
    iso4_df['color_g_r'] = (NewIsog[prob]) - (NewIsor[prob])
    iso3_df['mag_R'] = NewIsoR[prob]
    iso3_df['color_G_R'] = (NewIsoG[prob]) - (NewIsoR[prob])
    isom_df['mag_R'] = NewIsoR[prob]
    isom_df['color_G_R'] = (NewIsoG[prob]) - (NewIsoR[prob])
    #creating mask for around 21 to 25
    r4 = iso4_df['mag_r']
    r4_mask = (r4 > 21) & (r4 < 25)
    r4_mask.sum
    iso4_masked = iso4_df[r4_mask]
    iso4_masked.head()
    r4 = iso4_masked['mag_r']
    left4_color = iso4_masked['color_g_r'] - 0.4 * (r4/28)**5   #from 
    right4_color = iso4_masked['color_g_r'] + 0.8 * (r4/28)**5
    r3 = iso3_df['mag_R']
    r3_mask = (r3 > 21) & (r3 < 25)
    r3_mask.sum
    iso3_masked = iso3_df[r3_mask]
    iso3_masked.head()
    r3 = iso3_masked['mag_R']
    left3_color = iso3_masked['color_G_R'] - 0.4 * (r3/28)**5
    right3_color = iso3_masked['color_G_R'] + 0.8 * (r3/28)**5
    #middle
    rm = isom_df['mag_R']
    rm_mask = (rm > 21) & (rm < 22)
    rm_mask.sum
    isom_masked = isom_df[rm_mask]
    isom_masked.head()
    rm = isom_masked['mag_R']
    leftm_color = isom_masked['color_G_R'] - 0.4 * (rm/28)**5
    rightm_color = isom_masked['color_G_R'] + 0.8 * (rm/28)**5
    #Joinng the polygon together
    color4_loop = front_to_back(left4_color, right4_color)
    mag4_loop = front_to_back(r4,r4)
    color3_loop = front_to_back(left3_color, right3_color)
    mag3_loop = front_to_back(r3,r3)
    colorm_loop = front_to_back(leftm_color, rightm_color)
    magm_loop = front_to_back(rm,rm)
    #putting it into dataframe
    loop4_df = pd.DataFrame()
    loop4_df['color4_loop'] = color4_loop
    loop4_df['mag4_loop'] = mag4_loop
    loop3_df = pd.DataFrame()
    loop3_df['color3_loop'] = color3_loop
    loop3_df['mag3_loop'] = mag3_loop
    loopm_df = pd.DataFrame()
    loopm_df['colorm_loop'] = colorm_loop
    loopm_df['magm_loop'] = magm_loop
    polygon4 = Polygon(loop4_df)
    polygon3 = Polygon(loop3_df)
    polygonm = Polygon(loopm_df)
    points = pd.DataFrame()
    points['color'] = gmag-rmag
    points['mag'] = rmag
    inside4 = polygon4.contains_points(points)
    inside3 = polygon3.contains_points(points)
    insidem = polygonm.contains_points(points)
    inside = inside3 + inside4
    x = gmag[inside] - rmag[inside]
    y = rmag[inside]
    p = PCMD(x,y, iso3_df['color_G_R'], iso3_df['mag_R'], 
             iso4_df['color_g_r'],iso4_df['mag_r'])                                       
    return x, y, p, loop4_df, loop3_df, iso4_df, iso3_df, inside, insidem

#====================================================================
#Isochrone fitting probability ======================================
def isochrone(gmag,rmag,isoG,isoR,isog,isor):
    Prob = []
    for i in range(len(isoG)):
        Hey = PCMD_av(gmag-rmag,rmag,isoG[i]-isoR[i],isoR[i],isog[i]-isor[i],
                      isor[i])
        Prob.append(Hey)
    prob = Prob.index(np.max(Prob))
    return prob
#=====================================================================
#Selection cuts in radius
def cuts(c_Obs, immap, radius, radiusout, radiusin):
    select, dselect, distance = [], [], []
    for i in range(len(c_Obs)):
        Distance = immap.separation(c_Obs[i])
        distance.append(Distance)
        Select = distance[i].degree < radius
        select.append(Select)
        Dselect = (distance[i].degree < radiusout) & (distance[i].degree > radiusin)
        dselect.append(Dselect)
    return select, dselect

#====================================================================
def cmd_plot(fig, axs, index, colouR, colour, maG, mag, x, y, colour4, mag4, colour3, mag3, p, fieldg, fieldr, obj, i, oc):
    axs[index].plot(colour4,mag4)
    axs[index].plot(colour3,mag3)
    plt.plot (x,y,'go', markersize=0.5, alpha =0.5)
    axs[index].plot(colour,mag , c = '0.5')
    axs[index].plot(colouR,maG, c = '0.5')
    axs[index].set_xlim(-0.5,2.5)
    axs[index].set_ylim(20,26)
    cs = axs[index].scatter(x, y, marker = 'o', c=p, cmap = 'plasma')
    cbar= fig.colorbar(cs,  label = 'Membership Probability', ax=axs[i-oc])    
    #plot field
    axs[index].scatter(fieldg - fieldr, fieldr, color = 'black', alpha = 0.5)
    #set limits
    axs[index].set_xlim(-0.5,2.5)
    axs[index].set_ylim(20,26)
    #titles
    axs[index].set_title('Object'+str(obj))
    #Object = Object + 1
    axs[index].set_xlabel('g-r (mag)', fontsize = 12)
    axs[index].set_ylabel('r (mag)', fontsize = 12)
    return cbar
    

    
#Matching Coords ==================================================
def match_coords(coords_a, coords_b, label_a, label_b, decimals=2, approx=False):
    """
    Match two lists of SkyCoord objects by rounded RA/Dec.

    Parameters
    ----------
    coords_a, coords_b : list[SkyCoord]
        Lists of astropy SkyCoord objects.
    label_a, label_b : str
        Labels used in print output, e.g. "S", "G", "SG", "T".
    decimals : int
        Number of decimal places to round to before matching.
        (Your original code uses 2 for exact, 1 for telescope comparisons.)
    approx : bool
        If True, prints '≈' instead of '='.
    """
    if coords_a is None or coords_b is None:
        return

    # Convert to rounded tuples for easy comparison
    a_rounded = [(round(c.ra.deg, decimals), round(c.dec.deg, decimals)) for c in coords_a]
    b_rounded = [(round(c.ra.deg, decimals), round(c.dec.deg, decimals)) for c in coords_b]

    symbol = "≈" if approx else "="

    # Speed-up: map coordinate -> indices in B (handles duplicates)
    b_index = {}
    for j, key in enumerate(b_rounded):
        b_index.setdefault(key, []).append(j)

    # Find matches
    for i, key in enumerate(a_rounded):
        if key in b_index:
            for j in b_index[key]:
                print(f"Object {i+1} ({label_a}) {symbol} Object {j+1} ({label_b})")
     
                

# For PAndAS Footprint ===============================================
def ellipse(ra,rb,ang,x0,y0,Nb=50):
    xpos,ypos=x0,y0
    radm,radn=ra,rb
    an=ang
    co,si=np.cos(an),np.sin(an)
    the=np.linspace(0,2*np.pi,Nb)
    X=radm*np.cos(the)*co-si*radn*np.sin(the)+xpos
    Y=radm*np.cos(the)*si+co*radn*np.sin(the)+ypos
    return X,Y

# DESI SCREENSHOTS =====================================================
def DESI(ra, dec):
    #driver = webdriver.Edge()
    service = Service(EdgeChromiumDriverManager().install())
    driver = webdriver.Edge(service=service)
    driver.get("https://www.legacysurvey.org/viewer")
    driver.maximize_window()
    time.sleep(2)
    info_tab = driver.find_element(By.XPATH, '/html/body/div/div[2]/div[1]/div[1]')
    time.sleep(1)
    info_tab.click()
    time.sleep(1)
    pyautogui.press('tab')
    time.sleep(1)
    pyautogui.typewrite(str(ra))
    time.sleep(1)
    pyautogui.press('tab')
    time.sleep(1)
    pyautogui.typewrite(str(dec))
    time.sleep(1)
    pyautogui.press('tab')
    time.sleep(1)
    pyautogui.typewrite('13')
    fly = driver.find_element(By.XPATH, '/html/body/div/div[2]/div[1]/div[1]/center/form/input[7]')
    time.sleep(1)
    fly.click()
    for _ in range(32):
        pyautogui.press('tab')
    time.sleep(1)
    for _ in range(3):
        pyautogui.press('right')
    time.sleep(1)
    pyautogui.press('tab')
    time.sleep(1)
    for _ in range(44):
        pyautogui.press('right')
    left = 630
    top = 300
    width = 600
    height = 600
    time.sleep(10)
    # Capture the screenshot of the specified area
    screenshot = ImageGrab.grab(bbox=(left, top, left + width, top + height))
    #fig_screenshot = plt.plot(screenshot)
    #plt.axis('off')
    return screenshot # Save the screenshot to a file
