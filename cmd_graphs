# -*- coding: utf-8 -*-
"""
Created on Mon Jan 19 20:01:23 2026

@author: bboyg
"""

import math as m
import numpy as np
import Functions as f
import matplotlib.pyplot as plt

from numpy import inf

def plot_cmd_mode(
    *,
    mode_label: str,                 # "S", "G", "SG" for printing
    c_obs,                           # output of f.setup(...)
    c_immap,                         # SkyCoord for star objects
    gmag_star_data,
    rmag_star_data,
    NewIsoG, NewIsoR, NewIsog, NewIsor,
    isochrone_labels,
    radius,
    radiusout,
    radiusin,
    cols: int = 5,
    ylim=(20, 26),
    fig_height_per_row: float = 40.0,
):
    """
        Creates plot for star, galaxy, star & galaxy, telescope data. 
        For this data, the coordinates for the overdensities are highlighted. 
        
        'Selects' shows the stars within one arcminute of the centre, 
        where 'deselects' shows the field population between 1.732 and 2 arcminutes. 
        
        Functions determine the optimal isochrone metallicity to use and calculates 
        the av membership probability for the memberstars and the field stars
        
        If the ratio between these numbers is <1.4, the candidate is removed and skipped to next one, If
        higher, the code creates strict CM cuts around the isochrone, and makes sure there is enough stars
        around for it candidate to be truely considered. 
        
        Plot this, with the field population on the same plot. This is repeated for all the overdensities until
        left with plot just showing the overdensities that meet the criteria.
    """
    # selects: stars within radius; dselects: field population annulus
    selects, dselects = f.cuts(c_obs, c_immap, radius, radiusout, radiusin)

    rows = m.ceil(len(c_obs) / cols) if len(c_obs) > 0 else 1
    fig, ax = plt.subplots(rows, cols, sharey=True)
    axs = ax.ravel()  # works for rows=1 and rows>1

    obj_num = 1
    coordinates = []
    oc = 0  #  “skip counter” that keeps subplot indexing aligned

    for i in range(len(c_obs)):
        oc += 1

        # skip if any inf in selected stars
        if any(value == inf for value in gmag_star_data[selects[i]]):
            continue
        oc -= 1

        # choose best-fitting isochrone (index into NewIso* arrays)
        prob = f.isochrone(
            gmag_star_data[selects[i]],
            rmag_star_data[selects[i]],
            NewIsoG, NewIsoR, NewIsog, NewIsor
        )

        PCMavs = f.PCMD_av(
            gmag_star_data[selects[i]] - rmag_star_data[selects[i]],
            rmag_star_data[selects[i]],
            NewIsoG[prob] - NewIsoR[prob], NewIsoR[prob],
            NewIsog[prob] - NewIsor[prob], NewIsor[prob]
        )

        fieldprobs = f.PCMD_av(
            gmag_star_data[dselects[i]] - rmag_star_data[dselects[i]],
            rmag_star_data[dselects[i]],
            NewIsoG[prob] - NewIsoR[prob], NewIsoR[prob],
            NewIsog[prob] - NewIsor[prob], NewIsor[prob]
        )

        Death = PCMavs / fieldprobs
        Sels = (Death > 1.4)

        oc += 1
        if Sels == False:
            continue
        oc -= 1

        # strict CMD box around isochrone and membership selection
        x, y, p, loop4_df, loop3_df, iso4_df, iso3_df, inside, insidem = f.box(
            prob,
            gmag_star_data[selects[i]],
            rmag_star_data[selects[i]],
            NewIsor, NewIsog, NewIsoR, NewIsoG
        )

        oc += 1
        if np.count_nonzero(inside) < 10:
            continue
        if np.count_nonzero(insidem) < 1:
            continue
        oc -= 1

        # plot into the correct subplot index
        subplot_index = i - oc
        f.cmd_plot(
            fig, axs, subplot_index,
            iso3_df['color_G_R'], iso4_df['color_g_r'],
            iso3_df['mag_R'], iso4_df['mag_r'],
            x, y,
            loop4_df['color4_loop'], loop4_df['mag4_loop'],
            loop3_df['color3_loop'], loop3_df['mag3_loop'],
            p,
            gmag_star_data[dselects[i]],
            rmag_star_data[dselects[i]],
            str(obj_num), i, oc
        )

        print(f"Object {obj_num} ({mode_label}) : Ratio = {Death} z = {isochrone_labels[prob]}")
        print("Coordinates:", c_obs[i])

        coordinates.append(c_obs[i])
        obj_num += 1

    # figure sizing
    final_plots = len(c_obs) - oc
    final_rows = m.ceil(final_plots / cols) if final_plots > 0 else 1

    
    fig.set_figheight(fig_height_per_row * final_rows)
    if final_plots > cols:
        fig.set_figwidth(30)
    else:
        fig.set_figwidth(30 - (3 * (cols - final_plots)))

    plt.ylim(*ylim)
    fig.gca().invert_yaxis()

    # delete unused axes
    total_axes = cols * rows
    if len(c_obs) > 0:
        unused = oc + (total_axes - len(c_obs))
        for k in range(unused):
            idx = (cols * (m.ceil(len(c_obs) / cols)) - 1) - k
            if 0 <= idx < len(axs):
                fig.delaxes(axs[idx])

    plt.show()

    return coordinates, fig

def Candidate_CMD(c_immap, candidate_coords, gmag_star_data, rmag_star_data,
                  NewIsoG, NewIsoR, NewIsog, NewIsor,
                  isochrone_labels,
                  radius = 0.016667, radiusin = 0.0288667, radiusout = 0.0333333):
    """
    This creates a new CMD for the updated coordinates (very much like before)
    It plots the member stars above the background stars, and in another plot,
    plots the field population.


    Returns
    -------
    fig_CMD

    """
    fig, ax = plt.subplots(1, 2,sharey=True, gridspec_kw={'width_ratios': [1, 1]})
    distance = c_immap.separation(candidate_coords)
    select = distance.degree < radius
    dselect = (distance.degree < radiusout) & (distance.degree > radiusin)
    prob = f.isochrone(gmag_star_data[select],rmag_star_data[select],NewIsoG,NewIsoR,NewIsog,NewIsor)
    PCMavs = f.PCMD_av(gmag_star_data[select] - rmag_star_data[select],rmag_star_data[select], (NewIsoG[prob]- NewIsoR[prob]), (NewIsoR[prob]),(NewIsog[prob]- NewIsor[prob]),(NewIsor[prob]))
    fieldprob = f.PCMD_av(gmag_star_data[dselect] - rmag_star_data[dselect],rmag_star_data[dselect], (NewIsoG[prob] - NewIsoR[prob]), (NewIsoR[prob]),(NewIsog[prob] - NewIsor[prob]),(NewIsor[prob]))
    ###PLOT AROUND CHOSEN SPACE
    x, y, p, loop4_df, loop3_df, iso4_df, iso3_df, inside, insidem = f.box(prob, gmag_star_data[select], rmag_star_data[select], NewIsor, NewIsog, NewIsoR, NewIsoG)
    #plotting desired Isochrone
    ax[0].plot(iso4_df['color_g_r'], iso4_df['mag_r'], c = '0.5')
    ax[0].plot(iso3_df['color_G_R'], iso3_df['mag_R'], c = '0.5')
    ax[1].plot(iso4_df['color_g_r'], iso4_df['mag_r'], c = '0.5')
    ax[1].plot(iso3_df['color_G_R'], iso3_df['mag_R'], c = '0.5')
    #plotting CM cuts
    ax[0].plot(loop4_df['color4_loop'],loop4_df['mag4_loop'])
    ax[0].plot(loop3_df['color3_loop'],loop3_df['mag3_loop'])
    #background stars
    ax[0].scatter(gmag_star_data-rmag_star_data,rmag_star_data,color = 'grey', alpha = 0.2, s = 10)
    #Plotting the stars more relatable to dwarf
    cs = ax[0].scatter(x, y, marker = 'o', c=p, cmap = 'plasma')
    cbar = plt.colorbar(cs,  label = 'Membership Probability')#, ax=axs[0])
    #Field population
    ax[1].scatter(gmag_star_data[dselect] - rmag_star_data[dselect], rmag_star_data[dselect], color = 'black', alpha = 0.5)
    #axis
    ax[0].set_xlim(-0.5,2.5)
    ax[0].set_ylim(20,26)
    ax[1].set_xlim(-0.5,2.5)
    ax[1].set_ylim(20,26)
    ax[0].set_title('Candidate', fontsize = 12)
    ax[0].set_xlabel('g-r (mag)', fontsize = 12)
    ax[0].set_ylabel('r (mag)', fontsize = 12)
    ax[1].set_title('Field', fontsize = 12)
    ax[1].set_xlabel('g-r (mag)', fontsize = 12)
    ax[0].set_aspect('equal')
    ax[1].set_aspect('equal')
    plt.gca().invert_yaxis()
    plt.subplots_adjust(wspace=0)
    plt.tight_layout()
    ratio = PCMavs/fieldprob
    metal_of_isochrone = isochrone_labels[prob]
    print('The ratio of a star being a member of a dwarf galaxy compared to the field population is', ratio)
    print('Isochrone Metallicity:', metal_of_isochrone)

    return fig, ratio, metal_of_isochrone
