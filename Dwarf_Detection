import data_processing as dp

import create_sig_maps as maps

import cluster_analysis_graphs as cluster

import cmd_graphs as CMD

import Functions as f

import pandas_map as panda

import Martin_sp as msp

import numpy as np
import astropy.units as u
from astropy.coordinates import SkyCoord, Angle
import matplotlib.pyplot as plt
import emcee
import corner
import os
import warnings
warnings.filterwarnings('ignore')

class DataAnalysis():
    def __init__(self, ra_file, dec_file):
        self.Folder = f'DATA/ra{ra_file}/dec{dec_file}'
        self.significance_map = None
        self.cluster_centers = None
        
        self.radius = 0.016667 #in degrees
        self.radiusin = 0.0288667 #in degrees
        self.radiusout = 0.0333333 # in degrees
        self.size = 0.01 # Size (in degrees) of each bin

        self.ra_cmd, self.dec_cmd = None, None
        self.x0m33, self.y0m33, self.rhm33 = None, None, None
        self.em33, self.tm33, self.nm33 = None, None, None
        self.Candidate_Coords = None
        self.c_immap = None
        self.five_arcmin = None
        self.rar, self.decr = None, None
        self.COORDINATES, self.COORDINATEG = None, None
        self.COORDINATESG, self.COORDINATET = None, None
        self.ratio = None
        self.metal_of_isochrone = None
        self.fig_CMD = None
        self.fig_rad = None
        self.fig_map = None
        self.fig_zoom = None


        self.ra_data, self.dec_data, self.ra_star_data, self.dec_star_data, self.ra_galaxy_data, self.dec_galaxy_data, self.gmag_star_data, self.rmag_star_data, self.telescope_image  = dp.data_import(ra_file, dec_file)

        # Isochrone data
        self.isochrone_labels, self.NewIsog, self.NewIsoG, self.NewIsor, self.NewIsoR = dp.load_isochrone_data()
        
        # Map data
        self.xs, self.ys, self.significance_maps, self.xbins, self.ybins = self.create_stellar_significance_map("stars")
        self.xg, self.yg, self.significance_mapg, self.xbing, self.ybing = self.create_stellar_significance_map("galaxies")
        self.xsg, self.ysg, self.significance_mapsg, self.xbinsg, self.ybinsg = self.create_stellar_significance_map("both")
        self.telecoords, self.IPB_masked, self.significant_coords_RA, self.significant_coords_Dec = maps.create_significance_map(
            self.telescope_image, self.xbinsg, self.ybinsg
        )
        
        # Cluster Analysis
        range_n_clusters = range(2, 40)
        davies_bouldin_avg, self.cluster_centers = cluster.perform_cluster_analysis(range_n_clusters, self.telecoords)
        cluster.Davies_Bouldin_graph(davies_bouldin_avg, range_n_clusters)
    
    def create_stellar_significance_map(self, mode="stars", significance_threshold=3.0):
        """
        This creates a number map of the data inputted. It bins stellar sources 
        with a pixel size of 0.01 deg. This can be adjusted in '__init__'. 
        Using an equation from Walsh 09, can create a significance map and areas
        that have a sigma > 3 compared to the background is highlighted.

        """
        # Select data based on mode
        if mode == "stars":
            ra, dec = self.ra_star_data, self.dec_star_data
            map_attr = ("xs", "ys", "xbins", "ybins", "significance_maps")
            title = "Star Significance Map"

        elif mode == "galaxies":
            ra, dec = self.ra_galaxy_data, self.dec_galaxy_data
            map_attr = ("xg", "yg", "xbing", "ybing", "significance_mapg")
            title = "Galaxy Significance Map"

        elif mode == "both":
            ra, dec = self.ra_data, self.dec_data
            map_attr = ("xsg", "ysg", "xbinsg", "ybinsg", "significance_mapsg")
            title = "Star + Galaxy Significance Map"

        else:
            raise ValueError("mode must be 'stars', 'galaxies', or 'both'")

        # Create histogram bins
        xbins = np.arange(np.min(ra), np.max(ra), self.size)
        ybins = np.arange(np.min(dec), np.max(dec), self.size)

        # 2D histogram
        immap, xedges, yedges = np.histogram2d(ra, dec, bins=(xbins, ybins))

        # Significance map
        sigmap = (immap - np.mean(immap)) / np.std(immap)

        # Significant pixels
        xsel, ysel = np.where(sigmap > significance_threshold)

        # Store results in the appropriate attributes
        setattr(self, map_attr[0], xsel)
        setattr(self, map_attr[1], ysel)
        setattr(self, map_attr[2], xedges)
        setattr(self, map_attr[3], yedges)
        setattr(self, map_attr[4], sigmap)

        # Plot
        plt.imshow(sigmap.T, origin='lower',
                   extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]],
                   cmap='plasma', interpolation='gaussian', aspect='auto')
        plt.colorbar()
        plt.scatter(xedges[xsel] + self.size/2,
                    yedges[ysel] + self.size/2,
                    marker='o', s=3, edgecolors='w')
        plt.title(title)
        plt.xlabel("Right Ascension (deg)")
        plt.ylabel("Declination (deg)")
        plt.show()
        
        return xsel, ysel, sigmap, xbins, ybins
    

    def plot_cmds(self):
        """
        Runs and plots CMDs for:
            1) Stars overdensities
            2) Galaxies overdensities
            3) Stars+Galaxies overdensities
            4) Telescope overdensities
        """

        # Make sure the stellar SkyCoord exists (your original CMD_star did this)
        self.c_immap = SkyCoord(self.ra_star_data, self.dec_star_data, frame='icrs', unit=(u.deg, u.deg))

        # --- Stars ---
        c_obs_s = f.setup(self.xbins, self.ybins, self.xs, self.ys, self.size)
        self.COORDINATES, _ = CMD.plot_cmd_mode(
            mode_label="S",
            c_obs=c_obs_s,
            c_immap=self.c_immap,
            gmag_star_data=self.gmag_star_data,
            rmag_star_data=self.rmag_star_data,
            NewIsoG=self.NewIsoG, NewIsoR=self.NewIsoR,
            NewIsog=self.NewIsog, NewIsor=self.NewIsor,
            isochrone_labels=self.isochrone_labels,
            radius=self.radius,
            radiusout=self.radiusout,
            radiusin=self.radiusin,
            cols=5,
            ylim=(20, 26),
            fig_height_per_row=40.0,
        )

        # --- Galaxies ---
        c_obs_g = f.setup(self.xbing, self.ybing, self.xg, self.yg, self.size)
        self.COORDINATEG, _ = CMD.plot_cmd_mode(
            mode_label="G",
            c_obs=c_obs_g,
            c_immap=self.c_immap,
            gmag_star_data=self.gmag_star_data,
            rmag_star_data=self.rmag_star_data,
            NewIsoG=self.NewIsoG, NewIsoR=self.NewIsoR,
            NewIsog=self.NewIsog, NewIsor=self.NewIsor,
            isochrone_labels=self.isochrone_labels,
            radius=self.radius,
            radiusout=self.radiusout,
            radiusin=self.radiusin,
            cols=5,
            ylim=(20, 26),
            fig_height_per_row=40.0,  # (you had 70 in CMD_galaxy; set to 70 if you want same)
        )

        # --- Stars + Galaxies ---
        c_obs_sg = f.setup(self.xbinsg, self.ybinsg, self.xsg, self.ysg, self.size)
        self.COORDINATESG, _ = CMD.plot_cmd_mode(
            mode_label="SG",
            c_obs=c_obs_sg,
            c_immap=self.c_immap,
            gmag_star_data=self.gmag_star_data,
            rmag_star_data=self.rmag_star_data,
            NewIsoG=self.NewIsoG, NewIsoR=self.NewIsoR,
            NewIsog=self.NewIsog, NewIsor=self.NewIsor,
            isochrone_labels=self.isochrone_labels,
            radius=self.radius,
            radiusout=self.radiusout,
            radiusin=self.radiusin,
            cols=5,
            ylim=(20, 26),
            fig_height_per_row=40.0,
        )

        # --- Telescope ---
        t_coords = np.column_stack((self.cluster_centers[:, 0], self.cluster_centers[:, 1]))
        ra_degrees = Angle(t_coords[:, 0], unit='degree')
        dec_degrees = Angle(t_coords[:, 1], unit='degree')
        c_obs_t = SkyCoord(ra=ra_degrees, dec=dec_degrees, frame='icrs')

        self.COORDINATET, _ = CMD.plot_cmd_mode(
            mode_label="T", c_obs=c_obs_t, c_immap=self.c_immap,
            gmag_star_data=self.gmag_star_data, rmag_star_data=self.rmag_star_data,
            NewIsoG=self.NewIsoG, NewIsoR=self.NewIsoR, NewIsog=self.NewIsog, NewIsor=self.NewIsor,
            isochrone_labels=self.isochrone_labels,
            radius=self.radius, radiusout=self.radiusout, radiusin=self.radiusin,
            fig_height_per_row=40.0
        )
        

    def Matching_Coords(self):
        """
        Shows which overdensities on the subplots matches with each other.

        Returns
        -------
        COORDINATES, COORDINATEG, COORDINATESG, COORDINATET

        """
        f.match_coords(self.COORDINATES,  self.COORDINATEG,  "S",  "G",  2, False)
        f.match_coords(self.COORDINATES,  self.COORDINATESG, "S",  "SG", 2, False)
        f.match_coords(self.COORDINATEG,  self.COORDINATESG, "G",  "SG", 2, False)
        f.match_coords(self.COORDINATES,  self.COORDINATET,  "S",  "T",  1, True)
        f.match_coords(self.COORDINATEG,  self.COORDINATET,  "G",  "T",  1, True)
        f.match_coords(self.COORDINATESG, self.COORDINATET,  "SG", "T",  1, True)
        
    def Coordinate(self):
        """
        Asks user to input chosen RA and dec

        Returns
        -------
        ra_cmd, dec_cmd.

        """
        self.ra_cmd, self.dec_cmd = input("RA:"), input("dec:")


    def MCMC(self):
        """
        This runs a MCMC on the chosen candiadate. Take approximate coordinates of the
        candidate and using some fix priors, and taking the X0 and Y0 prior as the stars
        within 5 arcminutes of the approximate centre. 
        Initial guesses are chosen and run in a burn in and then the MCMC
        It visualises the walkers and plots the results of the most likely values 
        of the different parameters. 
        A corner plot is then plotted and creates a new coordinates for the candidate

        Returns
        -------
        x0m33, y0m33, rhm33, em33, tm33, nm33

        """
        
        Candidate_Coords = SkyCoord(self.ra_cmd, self.dec_cmd, frame = 'icrs', unit=(u.deg,u.deg))
        racr = Candidate_Coords.ra.radian
        deccr = Candidate_Coords.dec.radian
        
        self.rar = self.c_immap.ra.radian
        self.decr = self.c_immap.dec.radian
        
        #deproject coordinates and convert to arcmin
        xsep = (self.rar - racr) * np.cos(deccr) * ((180. * 60.) /np.pi)
        ysep = (self.decr - deccr) * ((180. * 60.) /np.pi)
        dist = np.sqrt(xsep ** 2 + ysep ** 2)
        
        # data limits (colour cuts, radial cuts) for feeding into MCMC
        mag_lim = 26 
        col_lim_up = 2
        col_lim_dn = -0.5
        dist_lim = 2.5
        
        # enter priors for x and y
        priors = np.array([np.min(self.rar), np.max(self.rar), np.min(self.decr), np.max(self.decr),4])
        distance=self.c_immap.separation(Candidate_Coords)
        five_radius = 0.016667*5
        self.five_arcmin = distance.degree < five_radius
        cc = self.five_arcmin & (dist<dist_lim)  & (self.rmag_star_data < mag_lim) & (col_lim_dn<self.gmag_star_data - self.rmag_star_data) & (self.gmag_star_data - self.rmag_star_data< col_lim_up)
        
        #Initial guesses for the MCMC routine
        x0i = racr
        y0i = deccr
        #edit these to suit your data:
        ei = 0.2   #the ellipticity between 0-1 (roughly circular - lower values, very elliptical - higher values)
        rhi = 1  #the half-light radius (arc min) 
        ti =  0.5 #the postion angle (rad)
        ni = 15  #the approx number of stars that are dwarf galaxy 
        
        #===================================================================
        #MCMC
        #=================================================================== 
        initial=np.array([x0i, y0i, rhi, ei, ti, ni]) #feeds in initial guesses
        ndim, nwalkers = len(initial), 100 #sets number of dimensions (6 becuase we want to know six params) and number of walkers 
        pos = [np.array(initial) + 1e-4*np.random.randn(ndim) for i in range(nwalkers)] #sets initial postions for the 100 walkers
        sampler = emcee.EnsembleSampler(nwalkers, ndim, msp.lnp, args=(priors, self.rar[cc], self.decr[cc]))
        
        print('Running Burn-In...')
        burn = sampler.run_mcmc(pos, 1500, progress = True)
        sampler.reset()
        
        print('Running MCMC...')
        sampler.run_mcmc(burn, 4000, progress = True) #runs the analysis 10,000 times
        samples = sampler.get_chain(discard=100, thin=15, flat=True)#.reshape((-1,ndim))
        

        x_deg = ((samples[:, 0] * u.rad)).to(u.deg).value
        y_deg = ((samples[:, 1] * u.rad)).to(u.deg).value
        rh_arcmin = samples[:, 2]
        e = samples[:, 3]
        t_deg = ((samples[:, 4] * u.rad)).to(u.deg).value
        n = samples[:, 5]
        
        #Visualising Walkers
        fig, axes = plt.subplots(ndim, figsize = (9, 8), sharex=True)
        Labels= [r"RA [$^\circ$]", r"dec [$^\circ$]", r"$r_h [^\prime]$", r"$\epsilon$",r"$\theta[^\circ$]",r"$N_*$"]
        for i in range(ndim):
            ax = axes[i]
            ax.plot(samples[:,i], 'k', alpha = 0.5)
            ax.set_xlim(0, len(samples))
            ax.set_ylabel(Labels[i])
            ax.yaxis.set_label_coords(-0.1,0.5)
            
            
        np.set_printoptions(suppress=True,
                            formatter={'float_kind':'{:0.2f}'.format})
        
        data = np.array([x_deg, y_deg, rh_arcmin, e, t_deg, n]).T
        self.x0m33, self.y0m33, self.rhm33, self.em33, self.tm33, self.nm33 = map(lambda b: (b[1], b[2]-b[1], b[1]-b[0]), zip(*np.percentile(data, [16, 50, 84],axis=0)))
        np.set_printoptions(suppress = True)
        
        
        RA_CAND = Candidate_Coords.ra.deg
        DEC_CAND = Candidate_Coords.dec.deg
        ONA = ti*(180/np.pi)
        initials = [RA_CAND, DEC_CAND, rhi, ei, ONA, ni]

        # This part makes the corner plot
        figure = corner.corner(data, labels=[r"RA [$^\circ$]", r"dec [$^\circ$]", r"$r_h [^\prime]$", r"$\epsilon$", r"$\theta[^\circ]$", r"$N_*$"],
                       quantiles=[0.16, 0.5, 0.84], truths=initials, show_titles=True, title_kwargs={"fontsize": 16},
                       title_fmt=".3f",
                       label_kwargs={"fontsize": 18}, useOffset=False, labelpad=0.1)
        
        axes = np.array(figure.axes).reshape((ndim, ndim))
        from matplotlib.ticker import FormatStrFormatter
        
        for i in range(ndim):
            ax = axes[i, i]
            print(ax.title)
            
        axes[5,1].xaxis.set_major_formatter(FormatStrFormatter('%.3f'))
        plt.show()  
        
        # Creating new centre profile for overdensity
        self.Candidate_Coords = SkyCoord(self.x0m33[0], self.y0m33[0], frame = 'icrs', unit=(u.deg, u.deg))
        print('Candidate Coordinates:', self.x0m33[0], self.y0m33[0])

    def Candidate_Plots(self):
        """
        This creates a candiate CMD plot and radial profile plots.

        """
        self.fig_CMD, self.ratio, self.metal_of_isochrone = CMD.Candidate_CMD(
            self.c_immap, self.Candidate_Coords, self.gmag_star_data, self.rmag_star_data, 
            self.NewIsoG, self.NewIsoR, self.NewIsog, self.NewIsor, self.isochrone_labels
        )


        self.fig_rad = msp.Radial_Proflie(self.rar, self.decr, 
                                          self.x0m33, self.y0m33, 
                                          self.em33, self.tm33, self.nm33, 
                                          self.rhm33, self.five_arcmin, 
                                          self.c_immap, self.Candidate_Coords)

    def location_on_sig_map(self):
        """
        Plots the four density maps as seen before, but with a red circle around 
        the location of the candiate

        Returns
        -------
        Signficant Plots

        """
        #===================================================================
        #STAR MAP
        #===================================================================
        fig, ax = plt.subplots(2, 2, figsize = (11,9))  #creating a figure with 2 subplots
        axis_0 = ax[0,0].imshow(self.significance_maps.T, origin='lower',                 #star map
                                extent=[self.xbins[0], self.xbins[-1], self.ybins[0], self.ybins[-1]], label = 'Map',
                                cmap='plasma', interpolation='gaussian',
                                aspect='auto')
        fig.colorbar(axis_0, ax=ax[0,0]) 
        ax[0,0].scatter(self.xbins[self.xs]+self.size/2,self.ybins[self.ys]+self.size/2,marker='o',s=3,edgecolors = 'w')
        ax[0,0].set_title('Source: Stars', fontsize = 10)
        ax[0,0].set_xlabel('Right Ascension (deg)', fontsize = 10)
        ax[0,0].set_ylabel('Declination (deg)', fontsize = 10)
        #===================================================================
        #GALAXY MAP
        #===================================================================
        axis_00 = ax[0,1].imshow(self.significance_mapg.T, origin='lower',                 
                                 extent=[self.xbing[0], self.xbing[-1], self.ybing[0], self.ybing[-1]], label = 'Map',
                                 cmap='plasma', interpolation='gaussian',
                                 aspect='auto')
        fig.colorbar(axis_00, ax=ax[0,1])
        ax[0,1].scatter(self.xbing[self.xg]+self.size/2,self.ybing[self.yg]+self.size/2,marker='o',s=3,edgecolors = 'w')
        ax[0,1].set_title('Source: Galaxies', fontsize = 10)
        ax[0,1].set_xlabel('Right Ascension (deg)', fontsize = 10)
        ax[0,1].set_ylabel('Declination (deg)', fontsize = 10)
        #===================================================================
        #STAR AND GALAXY MAP
        #===================================================================
        axis_1 = ax[1,0].imshow(self.significance_mapsg.T, origin='lower',
                                extent=[self.xbinsg[0], self.xbinsg[-1], self.ybinsg[0], self.ybinsg[-1]], label = 'Map',
                                cmap='plasma', interpolation='gaussian',
                                aspect='auto')
        fig.colorbar(axis_1, ax=ax[1,0])
        ax[1,0].scatter(self.xbinsg[self.xsg]+self.size/2,self.ybinsg[self.ysg]+self.size/2,marker='o',s=3,edgecolors = 'w')
        ax[1,0].set_title('Source: Stars and Galaxies', fontsize = 10)
        ax[1,0].set_xlabel('Right Ascension (deg)', fontsize = 10)
        ax[1,0].set_ylabel('Declination (deg)', fontsize = 10)
        
        #===================================================================
        # Image from telescope
        #===================================================================
        # Load the image using OpenCV
        
        axis_3 = ax[1,1].imshow(self.IPB_masked.T, origin='lower', label='Map', extent=[self.xbinsg[0], self.xbinsg[-1], self.ybinsg[0], self.ybinsg[-1]],
                                cmap='plasma', interpolation='gaussian', aspect='auto')
        fig.colorbar(axis_3, ax=ax[1,1])
        # Scatter plot significant coordinates on top of the telescope image map
        ax[1,1].scatter(self.significant_coords_RA, self.significant_coords_Dec, marker='o', s=3, c='w')
        ax[1,1].scatter(self.cluster_centers[:,0],self.cluster_centers[:,1], marker='*', c='y', s=10)
        ax[1,1].set_title('Telescope Map', fontsize = 10)
        ax[1,1].set_xlabel('Right Ascension (deg)', fontsize = 10)
        ax[1,1].set_ylabel('Declination (deg)', fontsize = 10)
        
        #MARKERS
        for _ax in np.ravel(ax):
            _ax.scatter(self.Candidate_Coords.ra.deg, self.Candidate_Coords.dec.deg, s=80, facecolors='none', edgecolors='r')

        
    def Pandas(self):
        """
        Plots the location of the candidate on a map with respect to M33 and surround dwarf galaxies.
        The PAndAS survey is highlighted as well. 
        In addition, a zoomed in density plot is made to see the overdensity clearly
        on a significance map

        Returns
        -------
        Zoomed in density map and location of candidate with repsect to M33

        """
        
        self.fig_map = panda.Pandas(self.ra_data, self.dec_data, self.size, 
                     self.Candidate_Coords, self.x0m33, self.y0m33)
        self.fig_zoom = panda.zoom(self.ra_data, self.dec_data, self.size, self.Candidate_Coords)
        
    
    
    def saving_data(self):
        """
        If you want to save the data, you type 'y' and it saves the CMD, radial profile
        and zoomed density/PAndAS plot to file. In addition, it opens edge and goes to 
        the LIS skyviewer and takes a screen shot of the candidate with a Brightness = 5.4 
        and Contrast = 1.3

        Returns
        -------
        Folder w/ four plots.

        """
        Response = input("Do you want to save the data? (y/n): ")
        if Response == 'y':
            # create file path to save file
            base_dir = "~\\Candidates\\"
            #creating folder in chosen path to save png's
            results_dir = os.path.join(base_dir, f"Cand_{round(self.x0m33[0],3)}_{round(self.y0m33[0],3)}")
            os.makedirs(results_dir, exist_ok=True)
            # Save figures to the results directory
            cmd_file_path = os.path.join(results_dir, 'CMD.png')
            self.fig_CMD.savefig(cmd_file_path)
            radial_file_path = os.path.join(results_dir, 'Radial_Profile.png')
            self.fig_rad.savefig(radial_file_path)
            map_file_path = os.path.join(results_dir, 'Map.png')
            self.fig_map.savefig(map_file_path)
            zoom_file_path = os.path.join(results_dir, 'Zoom.png')
            self.fig_zoom.savefig(zoom_file_path)
            
            #Uses Desi function to take screen shot in DESI LIS Sky Viewer
            desi_file_path = os.path.join(results_dir, 'DESI.png')
            screenshot = f.DESI(str(self.x0m33[0]), str(self.y0m33[0]))
            screenshot.save(desi_file_path)
            print('Figures ae saved to:', results_dir)
            txt_file_path = os.path.join(results_dir, 'data.txt')
            txt = open(txt_file_path, "w")
            Lines = ['The Coordinates of the Candidate is: ', str(self.x0m33[0]), ' ', str(self.y0m33[0]), '\n', 
                     'The ratio of a star being a member of a dwarf galaxy compared to the field population is ', str(self.ratio), '\n',
                     'The isochrone used has a metallicity of: ', str(self.metal_of_isochrone)]
            txt.writelines(Lines)
            txt.close()     
        else:
            pass
